#pragma once

#include <boost/type_index.hpp>
#include <boost/type_index/runtime_cast/register_runtime_class.hpp>

#include <grpcpp/grpcpp.h>
#include <grpcpp/alarm.h>

#include "funwithgrpc/logging.h"
#include "funwithgrpc/Config.h"

template <typename grpcT>
struct ServerVars {
     // An instance of our service, compiled from code generated by protoc
    typename grpcT::AsyncService service_;

    // This is the Queue. It's shared for all the requests.
    std::unique_ptr<grpc::ServerCompletionQueue> cq_;

    [[nodiscard]] auto * cq() noexcept {
        assert(cq_);
        return cq_.get();
    }

    // A gRPC server object
    std::unique_ptr<grpc::Server> server_;

    void stop() {
        LOG_INFO << "Shutting down ";
        server_->Shutdown();
        server_->Wait();
    }
};

template <typename grpcT>
struct ClientVars {
    // This is the Queue. It's shared for all the requests.
    ::grpc::CompletionQueue cq_;

    [[nodiscard]] auto * cq() noexcept {
        return &cq_;
    }

    // This is a connection to the gRPC server
    std::shared_ptr<grpc::Channel> channel_;

    // An instance of the client that was generated from our .proto file.
    std::unique_ptr<typename grpcT::Stub> stub_;

    void stop() {
        // We don't stop the client...
        assert(false);
    }
};


template <typename T>
class EventLoopBase {
public:

    class RequestBase {
    public:
        struct Void {};

        class Handle
        {
        public:
            // In this implementation, the opertation is informative.
            // It has no side-effects.
            enum Operation {
                INVALID,
                CONNECT,
                READ,
                WRITE,
                WRITE_DONE,
                FINISH
            };

            using proceed_t = std::function<void(bool ok, Operation op)>;

            Handle(RequestBase& instance)
                : base_{instance} {}


            [[nodiscard]] void *tag(Operation op, proceed_t&& fn) noexcept {
                assert(op_ == Operation::INVALID);

                LOG_TRACE << "Handle::proceed() - " << base_.client_id_
                          << " executing " << op_ << " operation.";
                op_ = op;
                proceed_ = std::move(fn);
                return tag_();
            }

            void proceed(bool ok) {
                --base_.ref_cnt_;

                if (base_.owner_.config_.do_push_back_on_queue) {
                    // Handle failures immediately.
                    if (ok && !pushed_back_) {
                        // Work-around to push the event to the end of the queue.
                        // By default the "queue" works like a stack, which is not what most
                        // devs excpect or want.
                        // Ref: https://www.gresearch.com/blog/article/lessons-learnt-from-writing-asynchronous-streaming-grpc-services-in-c/
                        alarm_.Set(base_.cq(),
                                   gpr_now(gpr_clock_type::GPR_CLOCK_REALTIME),
                                   tag_());
                        pushed_back_ = true;
                        pushed_ok_ = ok;
                        LOG_TRACE << "Handle::proceed() - pushed the " << op_
                                  << " operation to the end of the queue.";
                        return;
                    }

                    if (pushed_back_) {
                        ok = pushed_ok_;

                        // Now we are ready for the next operation on this tag.
                        pushed_back_ = false;
                    }
                }

                // We must reset the `op_` type before we call `proceed_`
                // See the comment below regarding `proceed()`.
                const auto current_op = op_;
                op_ = Operation::INVALID;

                if (proceed_) {
                    LOG_TRACE << "Handle - caling proceed() on #"  << base_.client_id_
                              << " op=" << current_op << ", ok=" << ok;

                    // Move `proceed` to the stack.
                    // There is a good probablility that `proceed()` will call `tag()`,
                    // which will overwrite the current value in the Handle's instance.
                    auto proceed = std::move(proceed_);
                    proceed(ok, current_op);
                }

                if (base_.ref_cnt_ == 0) {
                    base_.done();
                }
            }

        private:
            [[nodiscard]] void *tag_() noexcept {
                ++base_.ref_cnt_;
                return this;
            }

            RequestBase& base_;
            Operation op_ = Operation::INVALID;
            proceed_t proceed_;
            bool pushed_back_ = false;
            bool pushed_ok_ = false;
            ::grpc::Alarm alarm_;
        };

        RequestBase(EventLoopBase& owner)
            : owner_{owner} {
            ++owner.num_open_requests_;
            LOG_TRACE << "Constructed request #" << client_id_ << " at address" << this;
        }

        virtual ~RequestBase() {
            --owner_.num_open_requests_;
        }

        auto * cq() noexcept {
            return owner_.cq();
        }

        template <typename reqT>
        static std::string me(reqT& req) {
            return boost::typeindex::type_id_runtime(req).pretty_name()
                   + " #"
                   + std::to_string(req.client_id_);
        }

    protected:
        // The state required for all requests
        EventLoopBase& owner_;
        int ref_cnt_ = 0;
        const size_t client_id_ = getNewClientId();

    private:
        void done() {
            // Ugly, ugly, ugly
            LOG_TRACE << "If the program crash now, it was a bad idea to delete this ;)  #"
                      << client_id_ << " at address " << this;
            delete this;
        }

        static size_t getNewClientId() {
            static size_t id = 0;
            return ++id;
        }

    }; // RequestBase;


    EventLoopBase(const Config& config)
        : config_{config} {}

    /*! Runs the event-loop
     *
     *  The method returns when/if the loop is finished
     *
     *  createNew<T> must have been called on all request-types that are used
     *  prior to this call.
     */
    void run() {
        assert(num_open_requests_ && "Must pre-create requests before calling run()!");

          // The inner event-loop
        while(num_open_requests_) {
            // The inner event-loop

            bool ok = true;
            void *tag = {};

            // FIXME: This is crazy. Figure out how to use stable clock!
            const auto deadline = std::chrono::system_clock::now()
                                  + std::chrono::milliseconds(1000);

            // Get any IO operation that is ready.
            const auto status = cq()->AsyncNext(&tag, &ok, deadline);
            LOG_TRACE << "async-next: ok=" << ok
                      << ", status=" << status
                      << ", tag=" << tag
                      << ", num_open_requests_=" << num_open_requests_;

            // So, here we deal with the first of the three states: The status from Next().
            switch(status) {
            case grpc::CompletionQueue::NextStatus::TIMEOUT:
                LOG_DEBUG << "AsyncNext() timed out.";
                continue;

            case grpc::CompletionQueue::NextStatus::GOT_EVENT:
                LOG_DEBUG << "AsyncNext() returned an event. The status is "
                          << (ok ? "OK" : "FAILED");

                // Use a scope to allow a new variable inside a case statement.
                {
                    auto request = static_cast<typename RequestBase::Handle *>(tag);

                    // Now, let the OneRequest state-machine deal with the event.
                    // We could have done it here, but that code would smell really nasty.
                    request->proceed(ok);
                }
                break;

            case grpc::CompletionQueue::NextStatus::SHUTDOWN:
                LOG_INFO << "SHUTDOWN. Tearing down the gRPC connection(s) ";
                return;
            } // switch
        } // loop
    }

    template <typename reqT, typename parenT>
    void createNew(parenT& parent) {

        // Use make_uniqe, so we destroy the object if it throws an exception
        // (for example out of memory).
        try {
            auto instance = std::make_unique<reqT>(parent);

            // If we got here, the instance should be fine, so let it handle itself.
            instance.release();
        } catch(const std::exception& ex) {
            LOG_ERROR << "Got exception while creating a new instance. "
                      << "This may end my ability to handle any further requests. "
                      << " Error: " << ex.what();
        }
    }

    void stop() {
        grpc_.stop();
    }

    auto& grpc() {
        return grpc_;
    }

    auto * cq() noexcept {
        return grpc_.cq();
    }

    const auto& config() noexcept {
        return config_;
    }

protected:
    const Config& config_;
    size_t num_open_requests_ = 0;
    T grpc_;
}; // EventLoopBase;

